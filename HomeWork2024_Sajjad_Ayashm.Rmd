---
title: "R HomeWork2024"
author: "Sajjad Ayashm"
date: "2024-10-21"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(knitr)
```

## Question 1
### Reading Data from mobility.csv

In this step, we read the historical occupational mobility data from the CSV file. The first column contains row names, so we specify row.names = 1 to treat them as such. We then convert the data frame into a matrix format:

```{r}
mobility_data <- read.csv('mobility.csv', sep = ';', row.names = 1)
mobility <- as.matrix(mobility_data, byrow= FALSE)

kable(head(mobility), caption = "Preview of Mobility Data")
```
## Question 2 
### Using Matrix Package to Create a Sparse Matrix


We load the Matrix package to handle sparse matrices. We then convert the mobility matrix into a sparse matrix, which is a more efficient storage format for matrices with many zeros.

```{r}

library(Matrix)
sparse_mobility <- Matrix(data = mobility, sparse = TRUE)

```


#### Comparing Size of Dense and Sparse Matrices
Here, we compare the memory sizes of the original dense matrix (mobility) and the sparse matrix (sparse_mobility) to see how much space is saved by using the sparse representation.

```{r eval =TRUE}
dence_size <- object.size(mobility)
spare_size <- object.size(sparse_mobility)
```

The size of the dense matrix mobility is *`r dence_size` bytes* and the size of the sparse matrix sparse_mobility is *`r spare_size` bytes*.

## Question 3
### Proportion of Zeros in an R Object

In this task, we need to write a function called `sparseProp()` that calculates the proportion of zeros in an R object (such as a vector or matrix). The function works by counting the number of zeros and dividing it by the total number of elements.


``` {r eval =TRUE}
sparseProp <- function(x){
  total_elements <- length(x)
  
  total_zero <- sum(x == 1)
  
  proportion <- total_zero / total_elements
  return(proportion)
}
```

#### Example of using `sparseProp()`


We can now test the function with an example vector and also apply it to the mobility matrix to see the proportion of zeros in both cases.

``` {r}
p <- sparseProp(sparse_mobility)
print(p)
```


## Question 4
### Extracting the Three Largest Values from the Mobility Matrix

We are tasked with extracting the three largest values from the `mobility` matrix: 54, 51, and 28. This can be done using an index matrix that contains the corresponding `row` and `column` names.

```{r}
index_matrix <- matrix(c('Div', 'DIV',
                         'Art', 'ART',
                         'Arm', 'ARM'),
                       nrow = 3, ncol =2, byrow =TRUE)
```

Extract the values using the index matrix:

```{r}
max_values <- mobility[as.matrix(index_matrix)]
```

The extracted values from the mobility matrix are:

- `r max_values[1]` from `(Div, DIV)`
- `r max_values[2]` from `(Art, ART)`
- `r max_values[3]` from `(Arm, ARM)`


## Question 5
### Frequency of Values in a Matrix

In this task, we need to write a function called `freqOfFreq()` that calculates the frequency of each unique value in a matrix. The function will raise an error if the input is not a matrix.

```{r}
freqOfFreq <- function(x){
  stopifnot("the input of function should be a matrix" = is.matrix(x))
  
  freq_table <- table(x, dnn = NULL)
  
  return(freq_table)
}
```
#### Working Example
We will apply the function to an example matrix and the mobility matrix, which are both valid inputs.

```{r}
freqOfFreq(mobility)
```
#### Error Example
We will now provide an invalid input to trigger the custom error message.
```{r error=TRUE}
freqOfFreq(sparse_mobility) # This will raise an error
```

We used the `stopifnot` function, embedded within our function, to trigger an error.

## Question 6
### Mean and Variance of the Frequency of Frequencies

In this question, we need to write two functions: `meanFOF()` and `varFOF()`. These functions calculate the *mean* and *variance* of the "frequency of frequencies" table generated by the `freqOfFreq()` function.

#### `meanFOF()` function of mean:
```{r eval =TRUE}
# Function to calculate the mean of the frequency of frequencies
meanFOF <- function(freq_table) {
  # Convert the table to a numeric vector (the values of the table)
  freq_values <- as.numeric(names(freq_table))
  
  # Calculate the weighted mean of frequencies
  mean_value <- sum(freq_values * freq_table) / sum(freq_table)
  
  return(mean_value)
}
```

#### `varFOF()` function of variance:
```{r eval =TRUE}
varFOF <- function(freq_table){
  freq_values <- as.numeric(names(freq_table))
  # Calculate the mean of freq_table:
  mean_value <- meanFOF(freq_table)
  
  # Calculate the variance of freq_value
  variance <- sum((freq_values - mean_value)^2 * freq_table) / (sum(freq_table)-1)

  return(variance)
}
```
#### Example Usage of `meanFOF()` and `varFOF()`:
We will now calculate the *mean* and *variance* of the frequency of frequencies directly from the `mobility` matrix using a single line for each calculation.

```{r eval =TRUE}
# Calculate the mean and variance of the frequency of frequencies
mean_fof <- meanFOF(freqOfFreq(mobility))
var_fof <- varFOF(freqOfFreq(mobility))
```
The calculated mean of the frequency of frequencies is `r mean_fof`, and the variance is `r var_fof`.

## Question 7
### Expected Value for Each Cell in the Matrix

In this question, we calculate the expected frequency for each cell in a matrix using row and column totals. The `expected()` function takes a matrix as input and calculates the expected frequencies for each cell, assuming independence between rows and columns.

```{r eval=TRUE}
expected <- function(x){
  # raise error if x is not matrix
  stopifnot("the input of function should be a matrix"=is.matrix(x))
  
  # claculate expected value (without 'for' loop or other packages):
  row_total <- rowSums(x)
  col_total <- colSums(x)
  grand_total <- sum(x)
  
  expected_val <-  outer(row_total, col_total)/grand_total
  return(expected_val)
  
}
```

#### Example Usage of `expected()`
We can now apply the `expected()` function to our example matrix, `mobility`, to get the expected values for each cell.

```{r eval=FALSE}
# Calculate the expected values
expected(mobility)
```
```{r echo = FALSE}
kable(head(expected(mobility)), caption = "Expected Value of Mobility Data")
```
The resulting matrix displays the ***expected frequency*** for each cell, based on the row and column totals and assuming independence.

## Question 8
### Pearson Residuals

In this question, we calculate the Pearson residuals for each cell in the `mobility` matrix. The residuals indicate how much the observed values deviate from the expected values under the assumption of independence.

```{r}
# Define the Pearson residuals function with error handling for expected()
pearson <- function(x) {
  # Ensure input is a matrix
  stopifnot("The input of the function should be a matrix" = is.matrix(x))
  
  # Try to calculate expected values and catch any errors
  expected_matrix <- tryCatch({
    expected(x)
  }, error = function(e) {
    stop("Error in calculating expected values: ", e$message)
  })
  
  # Calculate Pearson residuals if expected values were calculated successfully
  residuals <- (x - expected_matrix) / sqrt(expected_matrix)
  
  return(residuals)
}
```

#### Example Usage of `pearson()`

We now apply the `pearson()` function to the `mobility` matrix to calculate and display the Pearson residuals.

```{r eval=FALSE}
# Calculate the expected values
pearson(mobility)
```
```{r echo = FALSE}
kable(head(pearson(mobility)), caption = "Pearson Residuals Value of Mobility Data")
```
The resulting matrix displays the ***Pearson residuals***, showing the deviations between *observed* and *expected* values for each cell in the contingency table.


## Question 9
###Pearson's Chi-Squared Statistic

In this question, we calculate Pearson's chi-squared statistic for the ***mobility*** matrix. This statistic indicates how much the observed values deviate from the expected values, assuming independence between rows and columns.

```{r}
# Define the Chi-squared function
chisquared <- function(x) {
  # Ensure input is a matrix
  stopifnot("The input of the function should be a matrix" = is.matrix(x))
  
  # Try to calculate expected values and catch any errors
  expected_matrix <- tryCatch({
    expected(x)
  }, error = function(e) {
    stop("Error in calculating expected values: ", e$message)
  })
  
  # Calculate Chi-squared statistic
  chisq <- sum(((x - expected_matrix)^2) / expected_matrix)
  
  # Set class as "chisquared"
  class(chisq) <- "chisquared"
  
  return(chisq)
}
```

#### Example Usage of `chisquared()`
We now apply the `chisquared()` function to the ***mobility*** matrix to compute the ***chi-squared*** statistic.
```{r eval=TRUE}
# Calculate Chi-squared statistic for the mobility matrix
custom_chisq <- chisquared(mobility)
```

The Pearson's chi-squared statistic for the **mobility** matrix, calculated using the custom `r chisquared(mobility)` function, is *`r custom_chisq`*.

## Conclusion

In this analysis, we calculated key statistical measures for the **mobility** matrix, including expected values, Pearson residuals, and Pearson's chi-squared statistic. The consistency of our custom calculations with Râ€™s built-in functions confirmed the accuracy of our approach, demonstrating a solid understanding of contingency table analysis and chi-squared testing for independence.

